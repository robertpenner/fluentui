'use client';

import * as React from 'react';
import {
  useControllableState,
  useEventCallback,
  useOnClickOutside,
  useOnScrollOutside,
  elementContains,
  useTimeout,
  isHTMLElement,
} from '@fluentui/react-utilities';
import { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';
import {
  usePositioning,
  resolvePositioningShorthand,
  mergeArrowOffset,
  usePositioningMouseTarget,
  PositioningProps,
} from '@fluentui/react-positioning';
import { useFocusFinders, useActivateModal } from '@fluentui/react-tabster';
import { arrowHeights } from '../PopoverSurface/index';
import type {
  OpenPopoverEvents,
  PopoverBaseProps,
  PopoverBaseState,
  PopoverProps,
  PopoverState,
} from './Popover.types';
import { popoverSurfaceBorderRadius } from './constants';
import { createPresenceComponent, presenceMotionSlot, motionTokens } from '@fluentui/react-motion';

const slideDistanceVarX = '--fui-positioning-slide-distance-x';
const slideDistanceVarY = '--fui-positioning-slide-distance-y';

const PopoverSurfaceMotion = createPresenceComponent<{ mainAxis: number }>(({ mainAxis = 50 }) => ({
  enter: [
    {
      keyframes: [{ opacity: 0 }, { opacity: 1 }],
      duration: motionTokens.durationSlower,
      easing: motionTokens.curveDecelerateMid,
      composite: 'replace',
    },
    {
      keyframes: [
        { transform: `translate3d(var(${slideDistanceVarX}), var(${slideDistanceVarY}), 0)` },
        { transform: 'translate3d(0, 0, 0)' },
      ],
      duration: motionTokens.durationSlower,
      easing: motionTokens.curveDecelerateMid,
      composite: 'accumulate',
    },
  ],
  exit: [],
}));

/**
 * Create the state required to render Popover.
 *
 * The returned state can be modified with hooks such as usePopoverStyles,
 * before being passed to renderPopover_unstable.
 *
 * @param props - props from this instance of Popover
 */
export const usePopover_unstable = (props: PopoverProps): PopoverState => {
  const { appearance, size = 'medium' } = props;
  const positioning = resolvePositioningShorthand(props.positioning);
  const withArrow = props.withArrow && !positioning.coverTarget;

  const { targetDocument } = useFluent();
  const targetWindow = targetDocument?.defaultView;

  const handlePositionEnd: NonNullable<PositioningProps['onPositioningEnd']> = useEventCallback(e => {
    console.log('onPositioningEnd', e);
    positioning.onPositioningEnd?.(e);

    const mainAxis = 10;

    const element = e.target;
    const placement = e.detail.placement;

    if (!isHTMLElement(element)) {
      return;
    }

    let slideDistanceX = 0;
    let slideDistanceY = mainAxis;

    const firstChars = placement.slice(0, 3);

    switch (firstChars) {
      case 'rig':
        slideDistanceX = -mainAxis;
        slideDistanceY = 0;
        break;

      case 'bot':
        slideDistanceX = 0;
        slideDistanceY = -mainAxis;
        break;

      case 'lef':
        slideDistanceX = mainAxis;
        slideDistanceY = 0;
        break;
    }

    element.style.setProperty(slideDistanceVarX, `${slideDistanceX}px`);
    element.style.setProperty(slideDistanceVarY, `${slideDistanceY}px`);
  });
  const state = usePopoverBase_unstable({
    ...props,
    positioning: {
      ...positioning,
      onPositioningEnd: handlePositionEnd,
      // Update the offset with the arrow size only when it's available
      ...(withArrow ? { offset: mergeArrowOffset(positioning.offset, arrowHeights[size]) } : {}),
    },
  });

  React.useEffect(() => {
    if (state.open) {
      const registerProperty =
        targetWindow?.CSS?.registerProperty ??
        (() => {
          // No-op if registerProperty is not supported
        });

      try {
        registerProperty({
          name: slideDistanceVarX,
          syntax: '<length>',
          inherits: false,
          initialValue: '0px',
        });
        registerProperty({
          name: slideDistanceVarY,
          syntax: '<length>',
          inherits: false,
          initialValue: '0px',
        });
      } catch (e) {
        // Ignore errors from registerProperty, which can occur if the properties are already registered
      }
    }
  }, [state.open, targetWindow]);

  return {
    appearance,
    size,
    ...state,
    surfaceMotion: presenceMotionSlot(props.surfaceMotion, {
      elementType: PopoverSurfaceMotion,
      defaultProps: {
        visible: state.open,
        appear: true,
        unmountOnExit: true,
      },
    }),
  };
};

/**
 * Base hook that builds Popover state for behavior and structure only.
 * Does not add design-related defaults such as appearance or size.
 * Does not manage focus behavior, it's handled by `usePopoverFocusManagement_unstable`.
 *
 * @internal
 * @param props - props from this instance of Popover
 */
export const usePopoverBase_unstable = (props: PopoverBaseProps): PopoverBaseState => {
  const [contextTarget, setContextTarget] = usePositioningMouseTarget();
  const initialState = {
    contextTarget,
    setContextTarget,
    ...props,
  } as const;

  const children = React.Children.toArray(props.children) as React.ReactElement[];

  if (process.env.NODE_ENV !== 'production') {
    if (children.length === 0) {
      // eslint-disable-next-line no-console
      console.warn('Popover must contain at least one child');
    }

    if (children.length > 2) {
      // eslint-disable-next-line no-console
      console.warn('Popover must contain at most two children');
    }
  }

  let popoverTrigger: React.ReactElement | undefined = undefined;
  let popoverSurface: React.ReactElement | undefined = undefined;
  if (children.length === 2) {
    popoverTrigger = children[0];
    popoverSurface = children[1];
  } else if (children.length === 1) {
    popoverSurface = children[0];
  }

  const [open, setOpenState] = useOpenState(initialState);

  const [setOpenTimeout, clearOpenTimeout] = useTimeout();
  const setOpen = useEventCallback((e: OpenPopoverEvents, shouldOpen: boolean) => {
    clearOpenTimeout();
    if (!(e instanceof Event) && e.persist) {
      // < React 17 still uses pooled synthetic events
      e.persist();
    }

    if (e.type === 'mouseleave') {
      // FIXME leaking Node timeout type
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      setOpenTimeout(() => {
        setOpenState(e, shouldOpen);
      }, props.mouseLeaveDelay ?? 500);
    } else {
      setOpenState(e, shouldOpen);
    }
  });

  const toggleOpen = React.useCallback<PopoverBaseState['toggleOpen']>(
    (e: OpenPopoverEvents) => {
      setOpen(e, !open);
    },
    [setOpen, open],
  );

  const positioningRefs = usePopoverRefs(initialState);
  const { targetDocument } = useFluent();

  useOnClickOutside({
    contains: elementContains,
    element: targetDocument,
    callback: ev => setOpen(ev, false),
    refs: [positioningRefs.triggerRef, positioningRefs.contentRef],
    disabled: !open,
    disabledFocusOnIframe: !(props.closeOnIframeFocus ?? true),
  });

  // only close on scroll for context, or when closeOnScroll is specified
  const closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;
  useOnScrollOutside({
    contains: elementContains,
    element: targetDocument,
    callback: ev => setOpen(ev, false),
    refs: [positioningRefs.triggerRef, positioningRefs.contentRef],
    disabled: !open || !closeOnScroll,
  });

  const { findFirstFocusable } = useFocusFinders();
  const activateModal = useActivateModal();

  React.useEffect(() => {
    if (props.unstable_disableAutoFocus) {
      return;
    }

    const contentElement = positioningRefs.contentRef.current;

    if (open && contentElement) {
      const shouldFocusContainer = !isNaN(contentElement.getAttribute('tabIndex') ?? undefined);
      const firstFocusable = shouldFocusContainer ? contentElement : findFirstFocusable(contentElement);

      firstFocusable?.focus();

      if (shouldFocusContainer) {
        // Modal activation happens automatically when something inside the modal is focused programmatically.
        // When the container is focused, we need to activate the modal manually.
        activateModal(contentElement);
      }
    }
  }, [findFirstFocusable, activateModal, open, positioningRefs.contentRef, props.unstable_disableAutoFocus]);

  return {
    ...initialState,
    ...positioningRefs,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    inertTrapFocus: props.inertTrapFocus ?? (props.legacyTrapFocus === undefined ? false : !props.legacyTrapFocus),
    popoverTrigger,
    popoverSurface,
    open,
    setOpen,
    toggleOpen,
    setContextTarget,
    contextTarget,
    inline: props.inline ?? false,
  };
};

/**
 * Creates and manages the Popover open state
 */
function useOpenState(
  state: Pick<PopoverBaseState, 'setContextTarget' | 'onOpenChange'> & Pick<PopoverBaseProps, 'open' | 'defaultOpen'>,
) {
  'use no memo';

  const onOpenChange: PopoverBaseState['onOpenChange'] = useEventCallback((e, data) => state.onOpenChange?.(e, data));

  const [open, setOpenState] = useControllableState({
    state: state.open,
    defaultState: state.defaultOpen,
    initialState: false,
  });
  state.open = open !== undefined ? open : state.open;
  const setContextTarget = state.setContextTarget;

  const setOpen = React.useCallback(
    (e: OpenPopoverEvents, shouldOpen: boolean) => {
      if (shouldOpen && e.type === 'contextmenu') {
        setContextTarget(e as React.MouseEvent);
      }

      if (!shouldOpen) {
        setContextTarget(undefined);
      }

      setOpenState(shouldOpen);
      onOpenChange?.(e, { open: shouldOpen });
    },
    [setOpenState, onOpenChange, setContextTarget],
  );

  return [open, setOpen] as const;
}

/**
 * Creates and sets the necessary trigger, target and content refs used by Popover
 */
function usePopoverRefs(
  state: Pick<PopoverBaseState, 'contextTarget'> &
    Pick<PopoverBaseProps, 'positioning' | 'openOnContext' | 'withArrow'>,
) {
  'use no memo';

  const positioningOptions = {
    position: 'above' as const,
    align: 'center' as const,
    arrowPadding: 2 * popoverSurfaceBorderRadius,
    target: state.openOnContext ? state.contextTarget : undefined,
    ...resolvePositioningShorthand(state.positioning),
  };

  // no reason to render arrow when covering the target
  if (positioningOptions.coverTarget) {
    state.withArrow = false;
  }

  const { targetRef: triggerRef, containerRef: contentRef, arrowRef } = usePositioning(positioningOptions);

  return {
    triggerRef,
    contentRef,
    arrowRef,
  } as const;
}
